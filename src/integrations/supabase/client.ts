
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { AdminUserAttributes, AuthError, GoTrueAdminApi, GoTrueAdminMFAApi, PageParams, Pagination, User, UserResponse } from '@supabase/supabase-js';

const SUPABASE_URL = "https://sbxltdbnqixucjoognfj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNieGx0ZGJucWl4dWNqb29nbmZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYxNDQxMDksImV4cCI6MjA2MTcyMDEwOX0.ZsH2LX5JVFk7tCC0gGmjP1ZrVlQJ78nSUlMqxW7L1rw";
// The service role key has more permissions for admin operations
const SUPABASE_SERVICE_ROLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNieGx0ZGJucWl4dWNqb29nbmZqIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NjE0NDEwOSwiZXhwIjoyMDYxNzIwMTA5fQ.RfqqbuZSLzn9YG_nRM8acM_GF_az2On38zK3NFGfJFI";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true
    }
  }
);

// Implementation for admin API functions
// These functions use the appropriate Supabase API endpoints and the service role key
const adminApiHeaders = {
  apikey: SUPABASE_SERVICE_ROLE_KEY,
  Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
  "Content-Type": "application/json"
};

// Create a proper AuthError with all required properties
const createAuthError = (message: string, status: number): AuthError => {
  const error = new Error(message) as AuthError;
  error.message = message;
  error.status = status;
  error.name = 'AuthApiError';
  error.code = `${status}`;
  
  // Since __isAuthError is protected, we need to use a workaround
  Object.defineProperty(error, '__isAuthError', {
    value: true,
    enumerable: false, // Make it non-enumerable like a protected property
    configurable: false
  });
  
  return error;
};

// Admin API implementation
const adminApi: Partial<GoTrueAdminApi> = {
  // Implemented methods
  async deleteUser(userId: string): Promise<UserResponse> {
    const response = await fetch(`${SUPABASE_URL}/auth/v1/admin/users/${userId}`, {
      method: 'DELETE',
      headers: adminApiHeaders
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      const error = createAuthError(
        errorData.message || 'Failed to delete user',
        response.status
      );
      return { data: { user: null }, error };
    }
    
    return { data: { user: null }, error: null };
  },

  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {
    try {
      const response = await fetch(`${SUPABASE_URL}/auth/v1/admin/users`, {
        method: 'POST',
        headers: adminApiHeaders,
        body: JSON.stringify(attributes)
      });
      
      const responseData = await response.json();
      
      if (!response.ok) {
        // Handle specific error for duplicate email
        if (response.status === 400 && responseData.msg?.includes('already exists')) {
          const error = createAuthError(
            'Este e-mail já está cadastrado no sistema',
            response.status
          );
          return { data: { user: null }, error };
        }
        
        const error = createAuthError(
          responseData.msg || responseData.message || 'Failed to create user',
          response.status
        );
        return { data: { user: null }, error };
      }
      
      return { data: { user: responseData }, error: null };
    } catch (e) {
      const error = createAuthError(
        e instanceof Error ? e.message : 'Unknown error creating user',
        500
      );
      return { data: { user: null }, error };
    }
  },

  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {
    try {
      const response = await fetch(`${SUPABASE_URL}/auth/v1/admin/users/${uid}`, {
        method: 'PUT',
        headers: adminApiHeaders,
        body: JSON.stringify(attributes)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        const error = createAuthError(
          errorData.msg || errorData.message || 'Failed to update user',
          response.status
        );
        return { data: { user: null }, error };
      }
      
      const userData = await response.json();
      return { data: { user: userData }, error: null };
    } catch (e) {
      const error = createAuthError(
        e instanceof Error ? e.message : 'Unknown error updating user',
        500
      );
      return { data: { user: null }, error };
    }
  },

  async listUsers(params: PageParams = { page: 1, perPage: 50 }): Promise<{ data: { users: User[], aud: string } & Pagination; error: null } | { data: { users: [] }; error: AuthError }> { 
    try {
      const response = await fetch(
        `${SUPABASE_URL}/auth/v1/admin/users?page=${params.page}&per_page=${params.perPage}`,
        {
          method: 'GET',
          headers: adminApiHeaders
        }
      );
      
      if (!response.ok) {
        const errorData = await response.json();
        return { 
          data: { users: [] }, 
          error: createAuthError(errorData.message || 'Failed to list users', response.status) 
        };
      }

      const data = await response.json();
      
      // Return properly formatted pagination result with aud field
      return { 
        data: { 
          users: data.users || [],
          aud: 'authenticated',
          ...data
        }, 
        error: null 
      };
    } catch (error: any) {
      return { 
        data: { users: [] }, 
        error: createAuthError(error.message || 'Failed to list users', 500)
      };
    }
  },
  
  async getUserById(uid: string): Promise<UserResponse> {
    try {
      const response = await fetch(`${SUPABASE_URL}/auth/v1/admin/users/${uid}`, {
        method: 'GET',
        headers: adminApiHeaders
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        const error = createAuthError(
          errorData.message || 'Failed to get user',
          response.status
        );
        return { data: { user: null }, error };
      }
      
      const userData = await response.json();
      return { data: { user: userData }, error: null };
    } catch (error: any) {
      return { 
        data: { user: null }, 
        error: createAuthError(error.message || 'Failed to get user', 500)
      };
    }
  },
  
  // Fix for signOut function to match the expected type signature
  async signOut(jwt: string, scope?: "global" | "local" | "others"): Promise<{ data: null; error: AuthError | null }> { 
    // Just return a success response as this is a stub implementation
    return { data: null, error: null }; 
  },

  async inviteUserByEmail(email: string, options?: { 
    redirectTo?: string, 
    data?: object 
  }): Promise<UserResponse> { 
    return { data: { user: null }, error: null }; 
  }
};

// Add required properties
const adminApiWithProps = {
  ...adminApi,
  mfa: {} as GoTrueAdminMFAApi,
  url: SUPABASE_URL,
  headers: adminApiHeaders,
  fetch: fetch.bind(window)
};

// Attach admin methods to the Supabase auth client using proper type casting
// We need to cast to unknown first, then to GoTrueAdminApi to avoid TypeScript errors
supabase.auth.admin = adminApiWithProps as unknown as GoTrueAdminApi;

// Add custom type for auth admin API
declare module '@supabase/supabase-js' {
  interface SupabaseAuthClient {
    admin: GoTrueAdminApi;
  }
}
